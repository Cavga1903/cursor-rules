---
alwaysApply: true
---

# Error Handling Rules - Hata YÃ¶netimi Best Practices

> âš ï¸ **Ã–NEMLÄ°:** Bu dosya her zaman uygulanÄ±r. Hata yÃ¶netimi kullanÄ±cÄ± deneyimi ve sistem gÃ¼venilirliÄŸi iÃ§in kritiktir.

---

## ğŸ¯ Error Handling Stratejisi

### 1. Error Types

**Error Kategorileri:**
- **User Errors** - KullanÄ±cÄ± hatasÄ± (validation, input)
- **System Errors** - Sistem hatasÄ± (network, database)
- **Programming Errors** - Programlama hatasÄ± (bugs, type errors)

---

### 2. Error Handling Hierarchy

```
User Action
    â†“
Frontend Validation (UX)
    â†“
API Call
    â†“
Backend Validation (Security)
    â†“
Business Logic
    â†“
Database
    â†“
Error Response
    â†“
Frontend Error Handling
    â†“
User Feedback
```

---

## ğŸ›¡ï¸ Frontend Error Handling

### 1. Try-Catch Blocks

**âŒ YanlÄ±ÅŸ (Error handling yok):**
```typescript
async function fetchUser(id: string) {
  const user = await invoke("get_user", { id });
  return user.name;  // Error durumunda crash
}
```

**âœ… DoÄŸru (Error handling):**
```typescript
async function fetchUser(id: string): Promise<string> {
  try {
    const user = await invoke<User>("get_user", { id });
    return user.name;
  } catch (error) {
    if (error instanceof Error) {
      console.error("Failed to fetch user:", error.message);
      throw new Error(`User not found: ${id}`);
    }
    throw error;
  }
}
```

---

### 2. Result Type Pattern

**âœ… DoÄŸru (Result type):**
```typescript
type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E };

async function fetchUser(id: string): Promise<Result<User>> {
  try {
    const user = await invoke<User>("get_user", { id });
    return { success: true, data: user };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error : new Error("Unknown error"),
    };
  }
}

// KullanÄ±m
const result = await fetchUser("123");
if (result.success) {
  console.log(result.data.name);
} else {
  console.error(result.error.message);
}
```

---

### 3. Error Boundaries (React)

**âœ… DoÄŸru (Error Boundary):**
```typescript
import { Component, ErrorInfo, ReactNode } from "react";

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("Error caught by boundary:", error, errorInfo);
    // Error logging service'e gÃ¶nder
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div>
          <h2>Something went wrong</h2>
          <p>{this.state.error?.message}</p>
        </div>
      );
    }

    return this.props.children;
  }
}

// KullanÄ±m
<ErrorBoundary fallback={<ErrorFallback />}>
  <App />
</ErrorBoundary>
```

---

## ğŸ”§ Backend Error Handling

### 1. Result Type (Rust)

**âœ… DoÄŸru (Rust Result type):**
```rust
use std::result::Result;

#[tauri::command]
fn get_user(id: String) -> Result<User, String> {
  // Validation
  if id.is_empty() {
    return Err("User ID cannot be empty".to_string());
  }
  
  // Database query
  let user = db.get_user(&id)
    .map_err(|e| format!("Database error: {}", e))?;
  
  // Business logic
  if user.is_deleted {
    return Err("User not found".to_string());
  }
  
  Ok(user)
}
```

---

### 2. Custom Error Types

**âœ… DoÄŸru (Custom error enum):**
```rust
#[derive(Debug)]
enum AppError {
  NotFound(String),
  Validation(String),
  Database(String),
  Unauthorized,
}

impl std::fmt::Display for AppError {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    match self {
      AppError::NotFound(msg) => write!(f, "Not found: {}", msg),
      AppError::Validation(msg) => write!(f, "Validation error: {}", msg),
      AppError::Database(msg) => write!(f, "Database error: {}", msg),
      AppError::Unauthorized => write!(f, "Unauthorized"),
    }
  }
}

#[tauri::command]
fn get_user(id: String) -> Result<User, AppError> {
  if id.is_empty() {
    return Err(AppError::Validation("User ID cannot be empty".to_string()));
  }
  
  let user = db.get_user(&id)
    .map_err(|e| AppError::Database(e.to_string()))?;
  
  if user.is_none() {
    return Err(AppError::NotFound(format!("User {} not found", id)));
  }
  
  Ok(user.unwrap())
}
```

---

## ğŸ“ Error Messages

### 1. User-Friendly Messages

**âŒ YanlÄ±ÅŸ (Technical error):**
```typescript
throw new Error("SQLITE_CONSTRAINT: UNIQUE constraint failed: users.email");
```

**âœ… DoÄŸru (User-friendly):**
```typescript
throw new Error("This email is already registered. Please use a different email.");
```

---

### 2. Error Message Structure

**âœ… DoÄŸru (Structured error):**
```typescript
interface AppError {
  code: string;
  message: string;
  details?: Record<string, unknown>;
}

function createError(
  code: string,
  message: string,
  details?: Record<string, unknown>
): AppError {
  return { code, message, details };
}

// KullanÄ±m
throw createError(
  "VALIDATION_ERROR",
  "Invalid email format",
  { field: "email", value: userInput }
);
```

---

## ğŸ”„ Error Recovery

### 1. Retry Logic

**âœ… DoÄŸru (Exponential backoff):**
```typescript
async function fetchWithRetry<T>(
  fn: () => Promise<T>,
  maxRetries = 3
): Promise<T> {
  let lastError: Error;
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error("Unknown error");
      
      // Exponential backoff
      const delay = Math.pow(2, i) * 1000; // 1s, 2s, 4s
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  throw lastError!;
}

// KullanÄ±m
const data = await fetchWithRetry(() => invoke("get_data"));
```

---

### 2. Fallback Values

**âœ… DoÄŸru (Fallback):**
```typescript
async function getUserName(id: string): Promise<string> {
  try {
    const user = await invoke<User>("get_user", { id });
    return user.name;
  } catch (error) {
    console.error("Failed to fetch user:", error);
    return "Unknown User";  // Fallback value
  }
}
```

---

## ğŸ“Š Error Logging

### 1. Structured Logging

**âœ… DoÄŸru (Structured logging):**
```typescript
interface LogEntry {
  level: "error" | "warn" | "info";
  message: string;
  error?: Error;
  context?: Record<string, unknown>;
  timestamp: string;
}

function logError(
  message: string,
  error?: Error,
  context?: Record<string, unknown>
) {
  const entry: LogEntry = {
    level: "error",
    message,
    error,
    context,
    timestamp: new Date().toISOString(),
  };
  
  // Console (development)
  if (process.env.NODE_ENV === "development") {
    console.error(entry);
  }
  
  // Error logging service (production)
  // sendToErrorService(entry);
}
```

---

### 2. Error Context

**âœ… DoÄŸru (Context ile):**
```typescript
try {
  await processPayment(orderId, amount);
} catch (error) {
  logError("Payment processing failed", error, {
    orderId,
    amount,
    userId: currentUser.id,
    timestamp: Date.now(),
  });
  throw error;
}
```

---

## ğŸš« Anti-Patterns

### 1. Silent Failures

**âŒ YanlÄ±ÅŸ:**
```typescript
try {
  await saveData(data);
} catch (error) {
  // Silent failure - kullanÄ±cÄ± bilgilendirilmiyor
}
```

**âœ… DoÄŸru:**
```typescript
try {
  await saveData(data);
} catch (error) {
  logError("Failed to save data", error);
  showErrorToast("Failed to save. Please try again.");
}
```

---

### 2. Catching Everything

**âŒ YanlÄ±ÅŸ:**
```typescript
try {
  // Code
} catch (error) {
  // TÃ¼m hatalarÄ± aynÄ± ÅŸekilde handle ediyor
  console.error(error);
}
```

**âœ… DoÄŸru:**
```typescript
try {
  // Code
} catch (error) {
  if (error instanceof ValidationError) {
    // Validation error handling
  } else if (error instanceof NetworkError) {
    // Network error handling
  } else {
    // Unknown error handling
  }
}
```

---

### 3. Error Swallowing

**âŒ YanlÄ±ÅŸ:**
```typescript
function processData(data: unknown) {
  try {
    return JSON.parse(data as string);
  } catch {
    return null;  // Error swallowed
  }
}
```

**âœ… DoÄŸru:**
```typescript
function processData(data: unknown): Result<Data> {
  try {
    const parsed = JSON.parse(data as string);
    return { success: true, data: parsed };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error : new Error("Parse error"),
    };
  }
}
```

---

## ğŸ“‹ Error Handling Checklist

### Frontend
- [ ] Try-catch blocks kullanÄ±ldÄ± mÄ±?
- [ ] Error boundaries var mÄ±? (React)
- [ ] User-friendly error messages var mÄ±?
- [ ] Error logging yapÄ±lÄ±yor mu?
- [ ] Fallback values tanÄ±mlÄ± mÄ±?

### Backend
- [ ] Result types kullanÄ±lÄ±yor mu?
- [ ] Custom error types var mÄ±?
- [ ] Error messages user-friendly mi?
- [ ] Error logging yapÄ±lÄ±yor mu?
- [ ] Error recovery stratejisi var mÄ±?

### General
- [ ] Silent failures yok mu?
- [ ] Error swallowing yok mu?
- [ ] Error context loglanÄ±yor mu?
- [ ] Retry logic var mÄ±? (network errors iÃ§in)

---

## ğŸ”— Referanslar

- [Error Handling in TypeScript](https://kentcdodds.com/blog/get-a-catch-block-error-message-with-typescript)
- [Rust Error Handling](https://doc.rust-lang.org/book/ch09-00-error-handling.html)
- [React Error Boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)

---

**Son GÃ¼ncelleme:** 2026-01-19  
**Versiyon:** 1.0.0
