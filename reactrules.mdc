---
alwaysApply: true
---
# React Performans Optimizasyon KurallarÄ±

> âš ï¸ **Ã–NEMLÄ°:** Bu dosya her zaman uygulanÄ±r. AyrÄ±ca `roadmaprules.mdc` dosyasÄ±nÄ± da kontrol et - roadmap Ã¶nceliklerine uy.

> ğŸ“‹ **Roadmap ReferansÄ±:** `_bmad-output/planning-artifacts/roadmap.mdc` - Åu anki Ã¶ncelik: **Test Infrastructure** (P3.1) ve **UI Refactor** (P3.3)

---

## ğŸ¤– AI Optimizasyonu - Context Window iÃ§in Kritik

**Problem:** AI araÃ§larÄ±nÄ±n (Cursor, Claude, Copilot) bir context window limiti var. 500+ satÄ±rlÄ±k component dosyalarÄ± AI'Ä±n anlamasÄ±nÄ± zorlaÅŸtÄ±rÄ±r.

**Ã‡Ã¶zÃ¼m:** 2 basit ESLint kuralÄ± ile AI iÃ§in optimize edilmiÅŸ kod yapÄ±sÄ±.

### AI Optimizasyon KurallarÄ±

**1. Maksimum SatÄ±r Limiti: 250 satÄ±r**
```javascript
// .eslintrc.js
'max-lines': ['error', {
  max: 250,
  skipBlankLines: true,
  skipComments: true
}]
```

**Neden 250 satÄ±r?**
- AI'Ä±n context window'unu aÅŸmamak iÃ§in
- React componentleri formatlamadan dolayÄ± daha fazla satÄ±r iÃ§erir
- Ã‡oÄŸu component iÃ§in yeterli
- Gereksiz bÃ¶lmelerden kaÃ§Ä±nÄ±r

**2. Dosya BaÅŸÄ±na Tek React Component**
```javascript
// .eslintrc.js
'react/no-multi-comp': ['error', { 
  ignoreStateless: false 
}]
```

**Neden tek component?**
- AI'Ä±n "bu dosya ne yapÄ±yor?" sorusuna net cevap verebilmesi iÃ§in
- Tek sorumluluk = Net cevap
- Refactoring Ã¶nerileri tutarlÄ± olur

**âŒ KÃ¶tÃ¼ Ã–rnek:**
```typescript
// UserProfile.tsx - 3 component aynÄ± dosyada
function UserAvatar() { ... }
function UserStats() { ... }
function UserProfile() { ... }

// AI dÃ¼ÅŸÃ¼ncesi: "Hangisini dÃ¼zelteyim? AralarÄ±ndaki iliÅŸki ne?"
```

**âœ… Ä°yi Ã–rnek:**
```typescript
// components/UserAvatar.tsx
function UserAvatar() { ... }

// components/UserStats.tsx
function UserStats() { ... }

// components/UserProfile.tsx
function UserProfile() { ... }

// AI dÃ¼ÅŸÃ¼ncesi: "UserAvatar, avatar gÃ¶steriyor. Bunu optimize edeyim."
```

### Bonus Kurallar

**3. Fonksiyon Boyutu Limiti: 50 satÄ±r**
```javascript
'max-lines-per-function': ['warn', {
  max: 50,
  skipBlankLines: true,
  skipComments: true
}]
```

**4. Dosya KarmaÅŸÄ±klÄ±ÄŸÄ±: 10**
```javascript
'complexity': ['warn', 10]
```

### Mevcut Proje Durumu

**âš ï¸ BÃ¼yÃ¼k Dosyalar (250+ satÄ±r):**
- `src/pages/StockPage.tsx` - 1227 satÄ±r âŒ
- `src/pages/POS.tsx` - 1117 satÄ±r âŒ
- `src/components/DashboardTab.tsx` - 635 satÄ±r âŒ
- `src/pages/SalesHistoryPage.tsx` - 556 satÄ±r âŒ
- `src/components/ProductsTab.tsx` - 548 satÄ±r âŒ
- `src/pages/ProductsPage.tsx` - 503 satÄ±r âŒ

**Refactoring Ã–nceliÄŸi:**
1. **POS.tsx** (1117 satÄ±r) - En kritik, en Ã§ok kullanÄ±lan
2. **StockPage.tsx** (1227 satÄ±r) - En bÃ¼yÃ¼k
3. **DashboardTab.tsx** (635 satÄ±r)
4. DiÄŸer sayfalar

### "Fix in Chat" AkÄ±ÅŸÄ±

**ESLint kurallarÄ± ile AI refactoring:**
1. Kod yazarsÄ±nÄ±z â†’ ESLint hata verir: "File has too many lines (324/250)"
2. "Fix in Chat" tÄ±klarsÄ±nÄ±z â†’ Cursor dosyayÄ± analiz eder
3. AI Ã¶nerir: "Bu dosyayÄ± 2 parÃ§aya bÃ¶lebilirim: ProductList ve ProductItem"
4. Kabul edersiniz â†’ Otomatik refactoring

**Manuel refactoring yapmak yerine, AI sizin iÃ§in en mantÄ±klÄ± bÃ¶lme noktasÄ±nÄ± buluyor.**

### Pratik Ä°puÃ§larÄ±

**1. Mevcut projeye uygularken:**
```javascript
// BaÅŸlangÄ±Ã§ta warn olarak baÅŸlayÄ±n
'max-lines': ['warn', { max: 300 }]

// Zamanla error'a Ã§evirin
'max-lines': ['error', { max: 250 }]
```

**2. BazÄ± dosyalarÄ± hariÃ§ tutun:**
```javascript
overrides: [
  {
    files: ['*.test.js', '*.stories.js'],
    rules: {
      'max-lines': 'off'
    }
  }
]
```

### SonuÃ§

**AI destekli development sadece AI kullanmak deÄŸildir. AynÄ± zamanda kod mimarinizi AI'Ä±n anlayabileceÄŸi ÅŸekilde yapÄ±landÄ±rmak da gereklidir.**

**2 basit ESLint kuralÄ±:**
- âœ… Max 250 satÄ±r per dosya
- âœ… Dosya baÅŸÄ±na tek React component

**Ã–zel konfigÃ¼rasyonlara gerek yok. ESLint zaten halihazÄ±rda projelerinizde var, sadece 2 kural eklemeniz yeterli.**

---

## Ã–ncelik Prensibi
Performans optimizasyonu bir checklist deÄŸil, bir Ã¶ncelik meselesi. YanlÄ±ÅŸ ÅŸeyi optimize etmek, hiÃ§ optimize etmemekten daha kÃ¶tÃ¼dÃ¼r.

**Ã–ncelik SÄ±rasÄ±:** Waterfall â†’ Bundle â†’ Server â†’ Client â†’ Re-render

---

## 1. Waterfall'larÄ± Ortadan KaldÄ±rma (KRÄ°TÄ°K)

Performans Ã§alÄ±ÅŸmalarÄ±nÄ±n Ã§oÄŸu baÅŸarÄ±sÄ±z olur Ã§Ã¼nkÃ¼ Ã§ok dÃ¼ÅŸÃ¼k seviyeden baÅŸlar. EÄŸer bir request waterfall 600ms bekleme sÃ¼resi ekliyorsa, useMemo optimizasyonlarÄ±nÄ±z ne kadar iyi olursa olsun pek bir ÅŸey ifade etmez.

### 1.1 BaÄŸÄ±msÄ±z Ä°ÅŸlemleri Paralel Ã‡alÄ±ÅŸtÄ±rÄ±n

âŒ **YanlÄ±ÅŸ KullanÄ±m** (arka arkaya await):
```typescript
const user = await fetchUser(id);
const posts = await fetchPosts(id);     // User bitene kadar bekliyor!
const comments = await fetchComments(id); // Posts bitene kadar bekliyor!
```

âœ… **DoÄŸru KullanÄ±m** (Promise.all):
```typescript
const [user, posts, comments] = await Promise.all([
  fetchUser(id),
  fetchPosts(id),
  fetchComments(id)
]);  // Hepsi aynÄ± anda baÅŸlar!
```

### 1.2 KoÅŸullu Veri Ã‡ekme

KullanÄ±lmayacak veriyi bekletmeyin. Ä°htiyaÃ§ olmayan if koÅŸullarÄ±nda async iÅŸlem baÅŸlatmayÄ±n.

âŒ **YanlÄ±ÅŸ** (Ã¶nce veri Ã§ekip sonra gerek olmadÄ±ÄŸÄ±na bakmak):
```typescript
async function handleRequest(userId, skipProcessing) {
  const userData = await fetchUserData(userId);
  if (skipProcessing) {
    return { skipped: true };  // userData bekledik ama kullanmadÄ±k!
  }
  return processUserData(userData);
}
```

âœ… **DoÄŸru** (Ã¶nce koÅŸul ile kontrol etmek):
```typescript
async function handleRequest(userId, skipProcessing) {
  if (skipProcessing) {
    return { skipped: true };  // Hemen dÃ¶n, bekleme yok
  }
  const userData = await fetchUserData(userId);
  return processUserData(userData);
}
```

### 1.3 useEffect Zincirleme'den KaÃ§Ä±nÄ±n

Birbirini tetikleyen useEffect'ler, birden fazla render dÃ¶ngÃ¼sÃ¼ne ve gecikmiÅŸ gÃ¼ncellemelere neden olur.

âŒ **YanlÄ±ÅŸ** (birden fazla effect):
```typescript
useEffect(() => {
  fetchUser().then(setUser);
}, []);

useEffect(() => {
  if (user) fetchPosts(user.id).then(setPosts);
}, [user]);

useEffect(() => {
  if (posts) fetchComments(posts[0].id).then(setComments);
}, [posts]);
```

âœ… **DoÄŸru** (tek useEffect):
```typescript
useEffect(() => {
  async function loadData() {
    const user = await fetchUser();
    const posts = await fetchPosts(user.id);
    const comments = await fetchComments(posts[0].id);
    setData({ user, posts, comments });
  }
  loadData();
}, []);
```

### 1.4 Data Fetching iÃ§in Render'Ä± Beklemeyin

Veri Ã§ekmeyi useEffect'te deÄŸil, sunucu seviyesine taÅŸÄ±yÄ±n (Next.js App Router Ã¶rneÄŸi):
```typescript
// Next.js App Router - Server Component
async function Page({ params }) {
  const data = await fetchData(params.id);  // Render baÅŸlamadan veri hazÄ±r
  return <ClientComponent data={data} />;
}
```

---

## 2. Bundle Boyutu Optimizasyonu (KRÄ°TÄ°K)

Her sayfada 300KB ekstra JavaScript gÃ¶nderiyorsanÄ±z, iÃ§ iÃ§e for dÃ¶ngÃ¼lerinden aldÄ±ÄŸÄ±nÄ±z performans karÄ± da fayda etmez. Bundle boyutu doÄŸrudan kullanÄ±cÄ± deneyimini etkiler.

### 2.1 Dynamic Import ile Lazy Loading

BÃ¼yÃ¼k bileÅŸenleri ihtiyaÃ§ anÄ±na kadar yÃ¼klemeyin:
```typescript
import { lazy, Suspense } from 'react';

// AÄŸÄ±r bileÅŸeni lazy load et
const HeavyChart = lazy(() => import('./HeavyChart'));

function Dashboard() {
  return (
    <Suspense fallback={<Skeleton />}>>
      <HeavyChart />
    </Suspense>
  );
}
```

### 2.2 Sadece Ä°htiyacÄ±nÄ±z OlanÄ± Import Edin

âŒ **YanlÄ±ÅŸ** (* karakteri kullanmak):
```typescript
import * as _ from 'lodash';  // TÃ¼m lodash'Ä± bundle'a ekler (~70KB)
import * as MaterialUI from '@material-ui/core';
```

âœ… **DoÄŸru** (sadece istenen metodu import etmek):
```typescript
import debounce from 'lodash/debounce';  // Sadece ihtiyacÄ±nÄ±z olan fonksiyon
import throttle from 'lodash/throttle';
import { Button, TextField } from '@material-ui/core';
```

### 2.3 Route BazlÄ± Kod BÃ¶lme (Tauri Desktop App iÃ§in)

**Tauri Desktop App'lerde route-based code splitting kritik Ã¶neme sahiptir.** Her route iÃ§in ayrÄ± chunk oluÅŸturun:

âŒ **YanlÄ±ÅŸ** (tÃ¼m sayfalar initial bundle'a dahil):
```typescript
import POS from "./pages/POS";
import OwnerDashboard from "./pages/OwnerDashboard";
import ProductsPage from "./pages/ProductsPage";
import StockPage from "./pages/StockPage";
// TÃ¼m sayfalar initial bundle'a dahil â†’ bÃ¼yÃ¼k bundle size
```

âœ… **DoÄŸru** (lazy loading ile route-based splitting):
```typescript
import { lazy, Suspense } from 'react';

// Lazy load pages - her route ayrÄ± chunk olur
const POS = lazy(() => import('./pages/POS'));
const OwnerDashboard = lazy(() => import('./pages/OwnerDashboard'));
const ProductsPage = lazy(() => import('./pages/ProductsPage'));
const StockPage = lazy(() => import('./pages/StockPage'));
const SalesHistoryPage = lazy(() => import('./pages/SalesHistoryPage'));
const UsersPage = lazy(() => import('./pages/UsersPage'));
const LoginPage = lazy(() => import('./pages/LoginPage'));

function AppRoutes() {
  return (
    <BrowserRouter>
      <Suspense fallback={<LoadingScreen />}>
        <Routes>
          <Route path="/login" element={<LoginPage />} />
          <Route path="/pos" element={<POS />} />
          <Route path="/owner/dashboard" element={<OwnerDashboard />} />
          {/* DiÄŸer routes... */}
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

**Tauri Desktop App iÃ§in Ã–zel Notlar:**
- Desktop app'lerde initial bundle size Ã§ok Ã¶nemli (ilk aÃ§Ä±lÄ±ÅŸ hÄ±zÄ±)
- Route-based splitting ile sadece aktif route yÃ¼klenir
- Login sayfasÄ± kÃ¼Ã§Ã¼k kalÄ±r, Owner dashboard sadece gerektiÄŸinde yÃ¼klenir
- POS sayfasÄ± ayrÄ± chunk olur, cashier'lar iÃ§in daha hÄ±zlÄ± baÅŸlangÄ±Ã§

### 2.4 Bundle Analizi YapÄ±n (Vite iÃ§in)

**Vite + Tauri Desktop App iÃ§in bundle analizi:**

âŒ **YanlÄ±ÅŸ** (bundle size'Ä± bilmeden optimize etmeye Ã§alÄ±ÅŸmak):
```typescript
// Hangi dependency ne kadar yer kaplÄ±yor bilinmiyor
import { everything } from 'large-library';
```

âœ… **DoÄŸru** (bundle analyzer ile Ã¶lÃ§Ã¼m yapmak):
```bash
# Vite iÃ§in bundle analyzer
npm install --save-dev rollup-plugin-visualizer

# vite.config.ts'e ekle:
import { visualizer } from 'rollup-plugin-visualizer';

export default defineConfig({
  plugins: [
    react(),
    visualizer({
      open: true,
      filename: 'dist/stats.html',
      gzipSize: true,
      brotliSize: true,
    }),
  ],
});

# Build sonrasÄ± dist/stats.html dosyasÄ± oluÅŸur
npm run build
```

**Bundle Analizi Checklist:**
- [ ] Initial bundle size < 500KB (Tauri desktop app iÃ§in hedef)
- [ ] Her route chunk < 200KB
- [ ] Duplicate dependencies tespit edildi mi?
- [ ] Gereksiz bÃ¼yÃ¼k kÃ¼tÃ¼phaneler var mÄ±?
- [ ] Tree shaking Ã§alÄ±ÅŸÄ±yor mu?

### 2.5 Client-Only KÃ¼tÃ¼phaneleri Dinamik YÃ¼kleyin

**Tauri Desktop App'lerde SSR yok, ama yine de heavy kÃ¼tÃ¼phaneleri lazy load edin:**

âŒ **YanlÄ±ÅŸ** (heavy kÃ¼tÃ¼phaneleri initial bundle'a dahil etmek):
```typescript
import Chart from 'chart.js';  // ~200KB - initial bundle'a eklenir
import MonacoEditor from 'monaco-editor';  // ~2MB - initial bundle'a eklenir
```

âœ… **DoÄŸru** (lazy loading ile ihtiyaÃ§ anÄ±nda yÃ¼klemek):
```typescript
// Tauri Desktop App - React.lazy kullan
import { lazy, Suspense } from 'react';

// Chart sadece dashboard'da lazily yÃ¼klenir
const Chart = lazy(() => import('chart.js'));

// Monaco Editor sadece code editor sayfasÄ±nda lazily yÃ¼klenir
const MonacoEditor = lazy(() => import('monaco-editor'));

function Dashboard() {
  return (
    <Suspense fallback={<ChartSkeleton />}>
      <Chart data={chartData} />
    </Suspense>
  );
}
```

**Tauri Desktop App iÃ§in Ã–zel Notlar:**
- Desktop app'lerde network latency yok, ama initial bundle size kritik
- Heavy libraries (charts, editors, visualization) lazy load edilmeli
- User interaction'a kadar beklet (hover, click, vb.)

---

## 3. Sunucu TarafÄ± PerformansÄ± (YÃœKSEK)

### 3.1 Server Components KullanÄ±n

Next.js App Router'da varsayÄ±lan olarak Server Components aktif. EtkileÅŸim gerektirmeyen bileÅŸenleri server'da render edin:
```typescript
// Bu bir Server Component (varsayÄ±lan)
async function ProductList() {
  const products = await db.products.findMany();
  
  return (
    <ul>
      {products.map(p => <li key={p.id}>{p.name}</li>)}
    </ul>
  );
}
```

### 3.2 Streaming ile Progressive Rendering

Suspense boundaries kullanarak sayfanÄ±n hazÄ±r olan kÄ±sÄ±mlarÄ±nÄ± Ã¶nce gÃ¶nderin:
```typescript
async function Page() {
  return (
    <div>
      <Header />  {/* Hemen render */}
      
      <Suspense fallback={<ProductSkeleton />}>
        <ProductList />  {/* Veri hazÄ±r olunca stream */}
      </Suspense>
      
      <Suspense fallback={<ReviewsSkeleton />}>
        <Reviews />  {/* BaÄŸÄ±msÄ±z stream */}
      </Suspense>
    </div>
  );
}
```

### 3.3 VeritabanÄ± SorgularÄ±nÄ± Optimize Edin

âŒ **N+1 Query Problemi** (2 defa sorgu atÄ±lÄ±yor):
```typescript
const posts = await db.posts.findMany();
for (const post of posts) {
  post.author = await db.users.findUnique({ where: { id: post.authorId } });
}
```

âœ… **Eager Loading** (include kullanÄ±n):
```typescript
const posts = await db.posts.findMany({
  include: { author: true }
});
```

### 3.4 Caching Stratejileri

Veri Ã§ekerken cache'ten yararlanÄ±n:
```typescript
// Next.js fetch cache
const data = await fetch(url, {
  next: { revalidate: 3600 }  // 1 saat cache
});

// Unstable cache (server actions)
import { unstable_cache } from 'next/cache';
const getCachedData = unstable_cache(
  async (id) => await db.find(id),
  ['data-cache'],
  { revalidate: 60 }
);
```

---

## 4. Client-Side Veri Ã‡ekme (ORTA-YÃœKSEK)

### 4.1 SWR veya React Query KullanÄ±n

Bu kÃ¼tÃ¼phaneler Ã¶nbellekleme, yeniden doÄŸrulama, optimistic updates ve deduplication saÄŸlar:
```typescript
import useSWR from 'swr';

function Profile() {
  const { data, error, isLoading } = useSWR('/api/user', fetcher, {
    revalidateOnFocus: true,
    dedupingInterval: 2000
  });
  if (isLoading) return <Skeleton />;
  if (error) return <Error />;
  return <User data={data} />;
}
```

### 4.2 Stale-While-Revalidate Stratejisi

Ã–nce Ã¶nbellekten gÃ¶ster, arka planda taze veri Ã§ek:
```typescript
const { data } = useSWR(key, fetcher, {
  revalidateOnMount: true,
  revalidateOnFocus: true,
  revalidateOnReconnect: true,
  refreshInterval: 30000  // 30 saniyede bir tazele
});
```

### 4.3 Optimistic Updates

Ä°stek atÄ±lmÄ±ÅŸ gibi Ã¶nceden data dÃ¶n. Ä°steÄŸi arka planda at:
```typescript
const { trigger } = useSWRMutation('/api/todos', updateTodo);

async function handleComplete(id) {
  await trigger(id, {
    optimisticData: (current) => 
      current.map(t => t.id === id ? { ...t, done: true } : t),
    rollbackOnError: true
  });
}
```

### 4.4 Pagination ve Infinite Scroll

Verilerin tamamÄ±nÄ± Ã§ekmek yerine pagination kullan:
```typescript
import useSWRInfinite from 'swr/infinite';

function Posts() {
  const { data, size, setSize } = useSWRInfinite(
    (index) => `/api/posts?page=${index + 1}`,
    fetcher
  );
  const posts = data ? data.flat() : [];
  const isLoadingMore = size > 0 && !data[size - 1];
  return (
    <>
      {posts.map(post => <Post key={post.id} {...post} />)}
      <button onClick={() => setSize(size + 1)} disabled={isLoadingMore}>
        Daha Fazla YÃ¼kle
      </button>
    </>
  );
}
```

---

## 5. Re-render Optimizasyonu (ORTA)

### 5.1 React.memo ile Gereksiz Render'larÄ± Ã–nleyin

**Vercel Best Practice:** Props deÄŸiÅŸmediyse bileÅŸenin yeniden render olmasÄ±nÄ± engelleyin. Ancak her yerde kullanmayÄ±n - sadece gerÃ§ekten pahalÄ± render'lar iÃ§in.

âŒ **YanlÄ±ÅŸ** (her component'i memo ile sarmak):
```typescript
// Gereksiz memo - basit component iÃ§in overhead
const SimpleButton = memo(function SimpleButton({ label }) {
  return <button>{label}</button>;
});
```

âœ… **DoÄŸru** (sadece pahalÄ± render'lar iÃ§in memo):
```typescript
// PahalÄ± list render - memo mantÄ±klÄ±
const ExpensiveProductList = memo(function ExpensiveProductList({ products }) {
  return products.map(product => (
    <ProductCard 
      key={product.id} 
      product={product}
      // PahalÄ± hesaplamalar burada
    />
  ));
}, (prevProps, nextProps) => {
  // Custom comparison - sadece products array deÄŸiÅŸtiyse re-render
  return prevProps.products.length === nextProps.products.length &&
         prevProps.products.every((p, i) => p.id === nextProps.products[i].id);
});

// Basit component - memo gereksiz
function SimpleButton({ label, onClick }) {
  return <button onClick={onClick}>{label}</button>;
}
```

**Tauri Desktop App iÃ§in Ã–zel Notlar:**
- Desktop app'lerde re-render overhead daha az kritik (network yok)
- Ama yine de bÃ¼yÃ¼k listeler iÃ§in memo kullan (POS cart, product list)
- Custom comparison function ile fine-grained control

### 5.2 useMemo ile PahalÄ± HesaplamalarÄ± Ã–nbelleÄŸe AlÄ±n

Her render'da Ã§alÄ±ÅŸmasÄ± gerekmeyen hesaplamalarÄ± memoize edin:
```typescript
const sortedItems = useMemo(() => {
  console.log('Sorting...');
  return [...items].sort((a, b) => a.price - b.price);
}, [items]);  // Sadece items deÄŸiÅŸtiÄŸinde yeniden hesapla

const filteredAndSorted = useMemo(() => {
  return items
    .filter(item => item.inStock)
    .sort((a, b) => a.name.localeCompare(b.name));
}, [items]);
```

### 5.3 useCallback ile Fonksiyon ReferanslarÄ±nÄ± Koruyun

Alt bileÅŸenlere geÃ§irilen fonksiyonlarÄ±n referansÄ±nÄ± useCallback ile sabitleyin:
```typescript
// âŒ Her render'da yeni fonksiyon
function Parent() {
  const handleClick = (id) => setSelected(id);
  return <MemoizedChild onClick={handleClick} />;
}

// âœ… Referans korunur
function Parent() {
  const handleClick = useCallback((id) => {
    setSelected(id);
  }, []);
  return <MemoizedChild onClick={handleClick} />;
}
```

### 5.4 State'i DoÄŸru Yerde Tutun

State'i mÃ¼mkÃ¼n olan en dÃ¼ÅŸÃ¼k seviyede tutun. Ä°lgili bileÅŸen kendi state'ini yÃ¶netsin.

âŒ **YanlÄ±ÅŸ** (State Ã§ok Ã¼st bileÅŸende duruyor):
```typescript
function App() {
  const [searchQuery, setSearchQuery] = useState('');
  return (
    <>
      <Header />  {/* searchQuery deÄŸiÅŸince gereksiz render */}
      <Sidebar />  {/* searchQuery deÄŸiÅŸince gereksiz render */}
      <SearchBox value={searchQuery} onChange={setSearchQuery} />
      <Results query={searchQuery} />
    </>
  );
}
```

âœ… **DoÄŸru** (State alt bileÅŸende):
```typescript
function App() {
  return (
    <>
      <Header />
      <Sidebar />
      <SearchSection />  {/* State burada izole */}
    </>
  );
}

function SearchSection() {
  const [searchQuery, setSearchQuery] = useState('');
  return (
    <>
      <SearchBox value={searchQuery} onChange={setSearchQuery} />
      <Results query={searchQuery} />
    </>
  );
}
```

### 5.5 Context BÃ¶lme

FarklÄ± hÄ±zlarda deÄŸiÅŸen deÄŸerleri ayrÄ± context'lere koyun:
```typescript
// âŒ Tek bÃ¼yÃ¼k context
const AppContext = createContext({ user, theme, notifications });

// âœ… AyrÄ±lmÄ±ÅŸ context'ler
const UserContext = createContext(null);
const ThemeContext = createContext('light');
const NotificationContext = createContext([]);
```

---

## 6. Render PerformansÄ± (ORTA)

### 6.1 Virtualization ile BÃ¼yÃ¼k Listeler

react-window veya react-virtualized kullanarak sadece gÃ¶rÃ¼nÃ¼r Ã¶ÄŸeleri render edin:
```typescript
import { FixedSizeList } from 'react-window';

function VirtualizedList({ items }) {
  return (
    <FixedSizeList
      height={600}
      width="100%"
      itemCount={items.length}
      itemSize={50}
    >
      {({ index, style }) => (
        <div style={style}>
          {items[index].name}
        </div>
      )}
    </FixedSizeList>
  );
}
```

### 6.2 Image Optimizasyonu

```typescript
import Image from 'next/image';

function ProductImage({ src, alt }) {
  return (
    <Image
      src={src}
      alt={alt}
      width={400}
      height={300}
      placeholder="blur"
      blurDataURL={shimmer}
      priority={false}  // Above-the-fold iÃ§in true
      loading="lazy"
    />
  );
}
```

**Temel kurallar:**
- `width` ve `height` belirtin (layout shift Ã¶nleme)
- `priority` prop ile above-the-fold gÃ¶rselleri Ã¶nceliklendirin
- `placeholder="blur"` ile dÃ¼ÅŸÃ¼k kaliteli Ã¶nizleme gÃ¶sterin
- Modern formatlar kullanÄ±n: WebP, AVIF

### 6.3 CSS-in-JS Dikkatli KullanÄ±n

CSS-in-JS runtime overhead ekler. Tailwind CSS veya CSS Modules tercih edin.

### 6.4 Layout Shift'i Ã–nleyin

```typescript
// Skeleton ile alan rezerve edin
function Card({ isLoading, data }) {
  if (isLoading) {
    return <div className="h-48 w-full bg-gray-200 animate-pulse" />;
  }
  return <div className="h-48">{data.content}</div>;
}

// Aspect ratio koruyun
<div className="aspect-video relative">
  <Image fill src={src} alt={alt} />
</div>
```

---

## 7. JavaScript PerformansÄ± (DÃœÅÃœK-ORTA)

### 7.1 DÃ¶ngÃ¼ Ä°terasyon SayÄ±sÄ±nÄ± AzaltÄ±n

AynÄ± array Ã¼zerinde birden fazla geÃ§iÅŸ yapmayÄ±n.

âŒ **YanlÄ±ÅŸ** (3 ayrÄ± geÃ§iÅŸ):
```typescript
const filtered = items.filter(x => x.active);
const mapped = filtered.map(x => transform(x));
const sorted = mapped.sort((a, b) => a.score - b.score);
```

âœ… **DoÄŸru** (reduce ile filter+map tek geÃ§iÅŸ):
```typescript
const result = items.reduce((acc, x) => {
  if (x.active) acc.push(transform(x));
  return acc;
}, []).sort((a, b) => a.score - b.score);
```

### 7.2 Object/Array Lookup Optimize Edin

Map objesi kullanarak arama iÅŸlemlerini optimize edin:
```typescript
// âŒ Array.find() - O(n)
const user = users.find(u => u.id === targetId);

// âœ… Map lookup - O(1)
const userMap = new Map(users.map(u => [u.id, u]));
const user = userMap.get(targetId);

// âœ… Object lookup - O(1)
const userById = Object.fromEntries(users.map(u => [u.id, u]));
const user = userById[targetId];
```

### 7.3 Debounce ve Throttle

Search iÅŸlemleri iÃ§in use-debounce kullanÄ±n:
```typescript
import { useDebouncedCallback } from 'use-debounce';

function SearchInput() {
  const [query, setQuery] = useState('');
  
  const debouncedSearch = useDebouncedCallback((value) => {
    fetchResults(value);
  }, 300);
  
  return (
    <input
      value={query}
      onChange={(e) => {
        setQuery(e.target.value);
        debouncedSearch(e.target.value);
      }}
    />
  );
}
```

### 7.4 Object Mutation'dan KaÃ§Ä±nÄ±n

```typescript
// âŒ Mutation - React deÄŸiÅŸikliÄŸi algÄ±lamaz
state.items.push(newItem);
setState(state);

// âœ… Immutable update
setState(prev => ({
  ...prev,
  items: [...prev.items, newItem]
}));
```

---

## 8. Ä°leri Seviye Patternler

### 8.1 Preloading Kritik Kaynaklar

prefetch kullanarak mouse hover olduÄŸu durumda veriyi Ã§ekin:
```typescript
// Hover'da prefetch
import { useRouter } from 'next/navigation';

function Link({ href, children }) {
  const router = useRouter();
  
  return (
    <a
      href={href}
      onMouseEnter={() => router.prefetch(href)}
      onClick={(e) => {
        e.preventDefault();
        router.push(href);
      }}
    >
      {children}
    </a>
  );
}
```

### 8.2 Font Fallback Ayarlama

Font fallback ayarlayarak en azÄ±ndan yakÄ±n fontlarÄ±n yÃ¼klenmesini saÄŸlayÄ±n:
```typescript
// next.config.js
const { fontFamily } = require('tailwindcss/defaultTheme');

module.exports = {
  theme: {
    fontFamily: {
      sans: ['Inter var', ...fontFamily.sans],
    },
  },
};
```

```css
/* Fallback font ayarÄ± */
@font-face {
  font-family: 'Inter';
  src: url('/fonts/Inter.woff2') format('woff2');
  font-display: swap;
  size-adjust: 100%;
  ascent-override: 90%;
  descent-override: 20%;
  line-gap-override: 0%;
}
```

### 8.3 React Compiler (React 19+)

React Compiler, useMemo ve useCallback'i otomatik olarak arka planda kodunuza ekler:
```javascript
// babel.config.js
module.exports = {
  plugins: [
    ['babel-plugin-react-compiler', {
      // compiler options
    }]
  ]
};
```

### 8.4 Web Workers ile AÄŸÄ±r Ä°ÅŸlemler

```typescript
// worker.js
self.onmessage = (e) => {
  const result = heavyComputation(e.data);
  self.postMessage(result);
};

// Component
function DataProcessor() {
  const [result, setResult] = useState(null);
  
  useEffect(() => {
    const worker = new Worker(new URL('./worker.js', import.meta.url));
    worker.postMessage(largeData);
    worker.onmessage = (e) => setResult(e.data);
    return () => worker.terminate();
  }, []);
  
  return <div>{result}</div>;
}
```

### 8.5 Intersection Observer ile Lazy Render

```typescript
function LazyComponent({ children }) {
  const [isVisible, setIsVisible] = useState(false);
  const ref = useRef(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsVisible(true);
          observer.disconnect();
        }
      },
      { rootMargin: '100px' }
    );
    
    if (ref.current) observer.observe(ref.current);
    return () => observer.disconnect();
  }, []);
  
  return <div ref={ref}>{isVisible ? children : <Placeholder />}</div>;
}
```

---

## Ã–ncelik Tablosu

1. **KRÄ°TÄ°K:** Waterfall'larÄ± ortadan kaldÄ±rma
2. **KRÄ°TÄ°K:** Bundle boyutu optimizasyonu
3. **YÃœKSEK:** Sunucu tarafÄ± performansÄ±
4. **ORTA-YÃœKSEK:** Client-side veri Ã§ekme
5. **ORTA:** Re-render optimizasyonu
6. **ORTA:** Render performansÄ±
7. **DÃœÅÃœK-ORTA:** JavaScript performansÄ±

---

## Ã–lÃ§me ve Test

**Ã–lÃ§meden optimize etme:**
- React DevTools Profiler
- Lighthouse
- Bundle analyzer
- Network tab

Tahmin etme, Ã¶lÃ§. Bazen "yavaÅŸ" sandÄ±ÄŸÄ±nÄ±z ÅŸey aslÄ±nda sorun deÄŸil.

---

## SonuÃ§

**ÃœÃ§ ÅŸeyi aklÄ±mÄ±zda tutalÄ±m:**

1. **SÄ±rayla git:** Waterfall â†’ Bundle â†’ Server â†’ Client â†’ Re-render. Bu sÄ±ra rastgele deÄŸil, gerÃ§ek metrikleri en Ã§ok etkileyen ÅŸeylerden baÅŸlÄ±yor.

2. **Ã–lÃ§meden optimize etme:** React DevTools Profiler, Lighthouse, bundle analyzer. Tahmin etme, Ã¶lÃ§. Bazen "yavaÅŸ" sandÄ±ÄŸÄ±nÄ±z ÅŸey aslÄ±nda sorun deÄŸil.

3. **Her hook'u her yere koyma:** `useCallback` ve `useMemo` bedava deÄŸil. Gereksiz yerde kullanmak kodu hem karmaÅŸÄ±klaÅŸtÄ±rÄ±r hem yavaÅŸlatÄ±r.

Ve eÄŸer React 19+ kullanÄ±yorsanÄ±z, React Compiler bu kararlarÄ±n Ã§oÄŸunu senin yerine verecek. Ama o zamana kadar, bu kurallar iyi bir pusula.

---

## ğŸ“š Vercel Labs React Best Practices Entegrasyonu

**Referans:** [Vercel Labs Agent Skills - React Best Practices](https://github.com/vercel-labs/agent-skills/tree/main/skills/react-best-practices)

**Bu dosya Vercel Labs'Ä±n React Best Practices skill'inden esinlenilerek oluÅŸturulmuÅŸtur ve Tauri Desktop App iÃ§in uyarlanmÄ±ÅŸtÄ±r.**

### Temel Prensipler

- âœ… **Ã–ncelik SÄ±rasÄ±:** Critical â†’ High â†’ Medium â†’ Low (Vercel'in Ã¶nerdiÄŸi sÄ±ra)
- âœ… **Kategori BazlÄ±:** 8 kategori (Waterfall, Bundle, Server, Client, Re-render, vb.)
- âœ… **Pratik Ã–rnekler:** Her kural iÃ§in doÄŸru/yanlÄ±ÅŸ Ã¶rnekler (Vercel pattern'i)
- âœ… **Tauri UyarlamasÄ±:** Desktop app iÃ§in Ã¶zel notlar ve optimizasyonlar

### Vercel Best Practices'ten Eklenenler

1. âœ… **Route-based code splitting** (Tauri iÃ§in uyarlanmÄ±ÅŸ - Section 2.3)
2. âœ… **Bundle analyzer setup** (Vite iÃ§in - Section 2.4)
3. âœ… **Client-only libraries lazy loading** (Section 2.5)
4. âœ… **React.memo best practices** (Ne zaman kullanÄ±lmalÄ± - Section 5.1)
5. âœ… **Component-level optimizations** (Section 5)

### Roadmap Entegrasyonu

- Bu kurallar `roadmap.mdc`'deki **Performance Optimization** (P3.4) ile uyumludur
- UI Refactor (P3.3) sÄ±rasÄ±nda bu kurallar Ã¶zellikle Ã¶nemlidir
- Bundle size optimization roadmap'te belirtilmiÅŸtir (< 500KB hedef)

### Tauri Desktop App Ã–zel NotlarÄ±

**Vercel'in web app odaklÄ± kurallarÄ± Tauri iÃ§in uyarlanmÄ±ÅŸtÄ±r:**

- **Route-based splitting:** Desktop app'lerde initial bundle size kritik (ilk aÃ§Ä±lÄ±ÅŸ hÄ±zÄ±)
- **Bundle analyzer:** Vite + rollup-plugin-visualizer kullanÄ±lmalÄ±
- **Lazy loading:** Network latency yok ama initial bundle size Ã¶nemli
- **Re-render optimization:** Desktop app'lerde daha az kritik ama bÃ¼yÃ¼k listeler iÃ§in Ã¶nemli

### KullanÄ±m

**Kod yazarken:**
1. Bu dosyadaki kurallarÄ± takip et
2. Vercel'in Ã¶ncelik sÄ±rasÄ±nÄ± uygula (Waterfall â†’ Bundle â†’ Server â†’ Client â†’ Re-render)
3. Tauri Desktop App iÃ§in Ã¶zel notlarÄ± dikkate al
4. Bundle analyzer ile Ã¶lÃ§Ã¼m yap (tahmin etme, Ã¶lÃ§)

**Roadmap ile uyum:**
- Performance Optimization (P3.4) sÄ±rasÄ±nda bu kurallar uygulanmalÄ±
- UI Refactor (P3.3) sÄ±rasÄ±nda bundle size ve lazy loading Ã¶nemli
- Test Infrastructure (P3.1) sonrasÄ± bu optimizasyonlar yapÄ±labilir
