---
alwaysApply: true
---

# TypeScript Best Practices - Type Safety ve Code Quality

> âš ï¸ **Ã–NEMLÄ°:** Bu dosya her zaman uygulanÄ±r. TypeScript projelerinde type safety ve code quality iÃ§in kritik kurallar.

---

## ğŸ¯ Type Safety KurallarÄ±

### 1. `any` KullanÄ±mÄ±ndan KaÃ§Ä±nÄ±n

**âŒ YanlÄ±ÅŸ:**
```typescript
function processData(data: any) {
  return data.value * 2;  // Type safety yok!
}
```

**âœ… DoÄŸru:**
```typescript
interface Data {
  value: number;
}

function processData(data: Data): number {
  return data.value * 2;  // Type-safe
}
```

**Alternatifler:**
- `unknown` kullanÄ±n (type guard ile)
- `Record<string, unknown>` (key-value pairs iÃ§in)
- Generic types (`<T>`)

---

### 2. Strict Mode KullanÄ±n

**tsconfig.json:**
```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "alwaysStrict": true
  }
}
```

**Neden?**
- Runtime hatalarÄ±nÄ± compile-time'da yakalar
- Daha gÃ¼venli kod
- Daha iyi IDE desteÄŸi

---

### 3. Type Inference'Ä± KullanÄ±n (Gereksiz Type Annotation'dan KaÃ§Ä±nÄ±n)

**âŒ YanlÄ±ÅŸ:**
```typescript
const name: string = "John";  // Gereksiz
const age: number = 25;        // Gereksiz
```

**âœ… DoÄŸru:**
```typescript
const name = "John";  // Type inference: string
const age = 25;       // Type inference: number
```

**Ancak, function return types belirtin:**
```typescript
// âœ… DoÄŸru - return type belirtilmeli
function calculateTotal(items: Item[]): number {
  return items.reduce((sum, item) => sum + item.price, 0);
}
```

---

### 4. Union Types ve Discriminated Unions

**âŒ YanlÄ±ÅŸ:**
```typescript
function handleEvent(event: string | number) {
  if (typeof event === "string") {
    // string iÅŸlemleri
  } else {
    // number iÅŸlemleri - ama ne tÃ¼r number?
  }
}
```

**âœ… DoÄŸru (Discriminated Union):**
```typescript
type ClickEvent = { type: "click"; x: number; y: number };
type KeyEvent = { type: "keypress"; key: string };
type Event = ClickEvent | KeyEvent;

function handleEvent(event: Event) {
  switch (event.type) {
    case "click":
      console.log(`Clicked at (${event.x}, ${event.y})`);
      break;
    case "keypress":
      console.log(`Key pressed: ${event.key}`);
      break;
  }
}
```

---

### 5. Type Guards KullanÄ±n

**âŒ YanlÄ±ÅŸ:**
```typescript
function processValue(value: unknown) {
  return value.length;  // Error: unknown'da length property yok
}
```

**âœ… DoÄŸru:**
```typescript
function isString(value: unknown): value is string {
  return typeof value === "string";
}

function processValue(value: unknown) {
  if (isString(value)) {
    return value.length;  // TypeScript artÄ±k value'nun string olduÄŸunu biliyor
  }
  throw new Error("Value must be a string");
}
```

---

## ğŸ“¦ Type Definitions

### 1. Interface vs Type Alias

**Interface kullanÄ±n:**
- Object shapes iÃ§in
- Extend edilebilir yapÄ±lar iÃ§in
- Declaration merging gerekiyorsa

```typescript
interface User {
  id: string;
  name: string;
}

interface Admin extends User {
  permissions: string[];
}
```

**Type Alias kullanÄ±n:**
- Union/Intersection types iÃ§in
- Primitive types iÃ§in
- Tuple types iÃ§in

```typescript
type Status = "pending" | "approved" | "rejected";
type UserId = string;
type Coordinates = [number, number];
```

---

### 2. Utility Types KullanÄ±n

**TypeScript'in built-in utility types:**

```typescript
// Partial - tÃ¼m property'ler optional
type PartialUser = Partial<User>;

// Required - tÃ¼m property'ler required
type RequiredUser = Required<PartialUser>;

// Pick - belirli property'leri seÃ§
type UserName = Pick<User, "name" | "email">;

// Omit - belirli property'leri Ã§Ä±kar
type UserWithoutId = Omit<User, "id">;

// Record - key-value mapping
type UserMap = Record<string, User>;

// Readonly - immutable
type ReadonlyUser = Readonly<User>;
```

---

### 3. Generic Types

**âŒ YanlÄ±ÅŸ (Type duplication):**
```typescript
function getFirstString(items: string[]): string | undefined {
  return items[0];
}

function getFirstNumber(items: number[]): number | undefined {
  return items[0];
}
```

**âœ… DoÄŸru (Generic):**
```typescript
function getFirst<T>(items: T[]): T | undefined {
  return items[0];
}

// KullanÄ±m
const firstString = getFirst<string>(["a", "b", "c"]);
const firstNumber = getFirst<number>([1, 2, 3]);
```

**Generic Constraints:**
```typescript
interface HasId {
  id: string;
}

function getById<T extends HasId>(items: T[], id: string): T | undefined {
  return items.find(item => item.id === id);
}
```

---

## ğŸ”’ Null Safety

### 1. Optional Chaining ve Nullish Coalescing

**âŒ YanlÄ±ÅŸ:**
```typescript
const name = user && user.profile && user.profile.name;
const count = items ? items.length : 0;
```

**âœ… DoÄŸru:**
```typescript
const name = user?.profile?.name;
const count = items?.length ?? 0;  // ?? sadece null/undefined iÃ§in
```

---

### 2. Non-null Assertion (Dikkatli KullanÄ±n)

**âŒ YanlÄ±ÅŸ (Gereksiz kullanÄ±m):**
```typescript
const name = user!.name;  // Runtime'da hata verebilir
```

**âœ… DoÄŸru (Type guard ile):**
```typescript
if (!user) {
  throw new Error("User not found");
}
const name = user.name;  // TypeScript artÄ±k user'Ä±n null olmadÄ±ÄŸÄ±nÄ± biliyor
```

**Sadece gerÃ§ekten emin olduÄŸunuzda kullanÄ±n:**
```typescript
// DOM element - render sonrasÄ± kesinlikle var
const button = document.getElementById("submit")!;
```

---

## ğŸ¨ Code Organization

### 1. Barrel Exports

**âŒ YanlÄ±ÅŸ:**
```typescript
// components/index.ts
export { Button } from "./Button";
export { Input } from "./Input";
export { Card } from "./Card";
// Her component iÃ§in ayrÄ± import
```

**âœ… DoÄŸru:**
```typescript
// components/index.ts
export { Button } from "./Button";
export { Input } from "./Input";
export { Card } from "./Card";

// KullanÄ±m
import { Button, Input, Card } from "./components";
```

---

### 2. Type-only Imports

**âŒ YanlÄ±ÅŸ:**
```typescript
import { User, UserService } from "./user";
// User type runtime'da kullanÄ±lmÄ±yor ama bundle'a dahil
```

**âœ… DoÄŸru:**
```typescript
import type { User } from "./user";
import { UserService } from "./user";
// User sadece type olarak import edildi
```

---

### 3. Namespace Imports (BÃ¼yÃ¼k KÃ¼tÃ¼phaneler Ä°Ã§in)

**âŒ YanlÄ±ÅŸ:**
```typescript
import { debounce, throttle, memoize, curry } from "lodash";
// TÃ¼m lodash bundle'a dahil olabilir
```

**âœ… DoÄŸru:**
```typescript
import debounce from "lodash/debounce";
import throttle from "lodash/throttle";
// Sadece ihtiyacÄ±nÄ±z olan fonksiyonlar
```

---

## ğŸš« Anti-Patterns

### 1. Type Assertion (as) KullanÄ±mÄ±ndan KaÃ§Ä±nÄ±n

**âŒ YanlÄ±ÅŸ:**
```typescript
const value = getValue() as string;  // GÃ¼venli deÄŸil
```

**âœ… DoÄŸru:**
```typescript
const value = getValue();
if (typeof value !== "string") {
  throw new Error("Value must be a string");
}
// ArtÄ±k value string olarak kullanÄ±labilir
```

---

### 2. @ts-ignore KullanÄ±mÄ±ndan KaÃ§Ä±nÄ±n

**âŒ YanlÄ±ÅŸ:**
```typescript
// @ts-ignore
const result = unsafeFunction();
```

**âœ… DoÄŸru:**
```typescript
// @ts-expect-error - AÃ§Ä±klama ekleyin
// Bu fonksiyon eski API kullanÄ±yor, yakÄ±nda gÃ¼ncellenecek
const result = unsafeFunction();
```

**Daha iyi:**
```typescript
// Type guard ile type safety saÄŸlayÄ±n
if (isValidResult(result)) {
  // Type-safe kullanÄ±m
}
```

---

### 3. Function Overloads (Gereksiz KullanmayÄ±n)

**âŒ YanlÄ±ÅŸ (Gereksiz overload):**
```typescript
function process(value: string): string;
function process(value: number): number;
function process(value: string | number): string | number {
  return value;
}
```

**âœ… DoÄŸru (Generic kullanÄ±n):**
```typescript
function process<T extends string | number>(value: T): T {
  return value;
}
```

**Ancak, farklÄ± return types gerekiyorsa overload kullanÄ±n:**
```typescript
function parse(input: string): Date;
function parse(input: number): Date;
function parse(input: string | number): Date {
  return new Date(input);
}
```

---

## ğŸ“š Best Practices Ã–zeti

1. âœ… **Strict mode aktif** - `tsconfig.json`'da `strict: true`
2. âœ… **`any` kullanmayÄ±n** - `unknown` veya proper types kullanÄ±n
3. âœ… **Type inference kullanÄ±n** - Gereksiz type annotation'dan kaÃ§Ä±nÄ±n
4. âœ… **Return types belirtin** - Function return types aÃ§Ä±k olsun
5. âœ… **Type guards kullanÄ±n** - Runtime type checking iÃ§in
6. âœ… **Utility types kullanÄ±n** - `Partial`, `Pick`, `Omit`, vb.
7. âœ… **Generic types kullanÄ±n** - Code duplication'dan kaÃ§Ä±nÄ±n
8. âœ… **Optional chaining** - `?.` ve `??` kullanÄ±n
9. âœ… **Type-only imports** - `import type` kullanÄ±n
10. âœ… **@ts-expect-error** - `@ts-ignore` yerine (aÃ§Ä±klama ile)

---

## ğŸ”— Referanslar

- [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)
- [TypeScript Deep Dive](https://basarat.gitbook.io/typescript/)
- [TypeScript Best Practices](https://github.com/typescript-cheatsheets/react)

---

**Son GÃ¼ncelleme:** 2026-01-19  
**Versiyon:** 1.0.0
